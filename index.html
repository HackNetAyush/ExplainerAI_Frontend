<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Video Explainer Chatbot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .chat-container {
            /* max-width: 1200px; */
            width: 100%;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.1);
        }

        .chat-header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .chat-header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .chat-header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
            scroll-behavior: smooth;
        }

        .message {
            margin-bottom: 20px;
            animation: fadeInUp 0.3s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            display: flex;
            justify-content: flex-end;
        }

        .message.bot {
            display: flex;
            justify-content: flex-start;
        }

        .message-content {
            max-width: 70%;
            padding: 15px 20px;
            border-radius: 20px;
            position: relative;
            word-wrap: break-word;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-bottom-right-radius: 5px;
        }

        .message.bot .message-content {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
            border-bottom-left-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 15px 20px;
            background: white;
            border-radius: 20px;
            border-bottom-left-radius: 5px;
            max-width: 70%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #007bff;
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.5;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .chat-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e0e0e0;
        }

       .chat-input-wrapper {
    display: flex;
    gap: 10px;
    align-items: flex-end;
    padding: 10px;
    box-sizing: border-box;
    max-width: 100%;
    width: 100%;
    flex-wrap: nowrap;
}

/* Make textarea grow and shrink smoothly */
.chat-input {
    flex: 1;
    padding: 15px 20px;
    border: 2px solid #e0e0e0;
    border-radius: 25px;
    font-size: 16px;
    resize: none;
    min-height: 50px;
    max-height: 120px;
    outline: none;
    transition: border-color 0.3s ease;
    width: 100%;
    box-sizing: border-box;
}

.chat-input:focus {
    border-color: #007bff;
}

.send-button {
    flex-shrink: 0;
    width: 50px;
    height: 50px;
    border: none;
    border-radius: 50%;
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    font-size: 18px;
}

.send-button:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(0, 123, 255, 0.3);
}

.send-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

/* Responsive adjustments for smaller screens */
@media (max-width: 600px) {
    .chat-input-wrapper {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
    }

    .chat-input {
        font-size: 14px;
        border-radius: 20px;
    }

    .send-button {
        width: 100%;
        height: 45px;
        border-radius: 20px;
        font-size: 16px;
    }
}

        

        .video-container {
            margin-top: 15px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .video-container video {
            width: 100%;
            height: auto;
        }

        .progress-container {
            background: #f0f0f0;
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            border: 1px solid #f5c6cb;
        }

        .canvas-container {
            display: none;
            margin-top: 15px;
        }

        #canvas {
            width: 100%;
            max-width: 640px;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            .chat-container {
                height: 100vh;
                margin: 0;
                border-radius: 0;
            }

            .message-content {
                max-width: 85%;
            }

            .chat-header h1 {
                font-size: 20px;
            }

            .chat-input-wrapper {
                flex-direction: column;
                gap: 15px;
            }

            .send-button {
                align-self: flex-end;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/ccapture.js-npmfixed@1.1.0/build/CCapture.all.min.js"></script>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>üé¨ AI Video Explainer</h1>
            <p>Ask me to create an educational video on any topic!</p>
        </div>

        <div class="chat-messages" id="chatMessages">
            <div class="message bot">
                <div class="message-content">
                    üëã Hi! I'm your AI video creator. Ask me to explain any topic and I'll generate a custom educational video for you!
                    <br><br>
                    <strong>Example:</strong> "Explain quantum physics" or "What is photosynthesis?"
                </div>
            </div>
        </div>

        <div class="chat-input-container">
            <div class="chat-input-wrapper">
                <textarea 
                    id="chatInput" 
                    class="chat-input" 
                    placeholder="Ask me to explain any topic..."
                    rows="1"
                ></textarea>
                <button id="sendButton" class="send-button">
                    <span>‚û§</span>
                </button>
            </div>
        </div>
    </div>

    <canvas id="canvas" width="1280" height="720" style="display: none;"></canvas>

    <script>
        class ChatBot {
            constructor() {
                this.chatID = this.generateChatID();
                this.messages = document.getElementById('chatMessages');
                this.input = document.getElementById('chatInput');
                this.sendButton = document.getElementById('sendButton');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.isProcessing = false;
                this.capturer = null;
                this.audioElement = null;
                
                this.initializeEventListeners();
            }

            generateChatID() {
                return 'chat_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                // return "testID"
            }

            initializeEventListeners() {
                this.sendButton.addEventListener('click', () => this.sendMessage());
                
                this.input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                this.input.addEventListener('input', () => {
                    this.autoResize();
                });
            }

            autoResize() {
                this.input.style.height = 'auto';
                this.input.style.height = Math.min(this.input.scrollHeight, 120) + 'px';
            }

            async sendMessage() {
                const message = this.input.value.trim();
                if (!message || this.isProcessing) return;

                this.addMessage(message, 'user');
                this.input.value = '';
                this.autoResize();
                this.setProcessing(true);

                this.showTypingIndicator();

                try {
                    await this.processVideoRequest(message);
                } catch (error) {
                    this.hideTypingIndicator();
                    this.addMessage(`Sorry, I encountered an error: ${error.message}`, 'bot', 'error');
                } finally {
                    this.setProcessing(false);
                }
            }

            addMessage(content, sender, type = 'normal') {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}`;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                if (type === 'error') {
                    contentDiv.innerHTML = `<div class="error-message">${content}</div>`;
                } else {
                    contentDiv.innerHTML = content;
                }
                
                messageDiv.appendChild(contentDiv);
                this.messages.appendChild(messageDiv);
                this.scrollToBottom();
                
                return contentDiv;
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'message bot';
                typingDiv.id = 'typingIndicator';
                
                const typingContent = document.createElement('div');
                typingContent.className = 'typing-indicator';
                typingContent.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
                
                typingDiv.appendChild(typingContent);
                this.messages.appendChild(typingDiv);
                this.scrollToBottom();
            }

            hideTypingIndicator() {
                const typingIndicator = document.getElementById('typingIndicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }

            setProcessing(processing) {
                this.isProcessing = processing;
                this.sendButton.disabled = processing;
                this.input.disabled = processing;
            }

            scrollToBottom() {
                setTimeout(() => {
                    this.messages.scrollTop = this.messages.scrollHeight;
                }, 100);
            }

            async processVideoRequest(prompt) {
                // Step 1: Send request to backend
                const response = await fetch('https://explainerai-backend.onrender.com/api/explain', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        chatID: this.chatID
                    })
                });

                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.message || 'Failed to generate content');
                }

                this.hideTypingIndicator();
                
                // Step 2: Show progress and start video generation
                const botMessageContent = this.addMessage(`
                    üé¨ Great! I'm creating a video about "${prompt}". This will take a moment...
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="progress-text" id="progressText">Fetching content...</div>
                    </div>
                `, 'bot');

                try {
                    // Step 3: Fetch JSON and audio
                    await this.fetchAndGenerateVideo(prompt, botMessageContent);
                } catch (error) {
                    botMessageContent.innerHTML = `
                        <div class="error-message">
                            ‚ùå Failed to generate video: ${error.message}
                        </div>
                    `;
                }
            }

            async fetchAndGenerateVideo(prompt, messageContainer) {
                const progressFill = messageContainer.querySelector('#progressFill');
                const progressText = messageContainer.querySelector('#progressText');

                // Update progress
                const updateProgress = (percent, text) => {
                    if (progressFill) progressFill.style.width = `${percent}%`;
                    if (progressText) progressText.textContent = text;
                };

                updateProgress(20, 'Fetching video content...');

                // Fetch JSON
                const jsonUrl = `https://explainerai-backend.onrender.com/${this.chatID}/json/j1.json`;
                const jsonResponse = await fetch(jsonUrl);
                const slidesData = await jsonResponse.json();

                updateProgress(40, 'Loading audio...');

                // Fetch and load audio
                const audioUrl = `https://explainerai-backend.onrender.com/${this.chatID}/merged/output.wav`;
                const audioElement = new Audio();
                await new Promise((resolve, reject) => {
                    audioElement.onloadeddata = resolve;
                    audioElement.onerror = reject;
                    audioElement.src = audioUrl;
                });

                updateProgress(60, 'Generating video frames...');

                // Generate video
                const videoBlob = await this.generateVideo(slidesData, (progress) => {
                    updateProgress(60 + (progress * 0.35), `Rendering video... ${Math.round(progress)}%`);
                });

                updateProgress(100, 'Video ready!');

                // Step 4: Create final video with audio
                this.createFinalVideoPlayer(videoBlob, audioElement, prompt, messageContainer);
            }

            async generateVideo(slidesData, progressCallback) {
                return new Promise((resolve, reject) => {
                    try {
                        // Convert slides format
                        let currentTime = 0;
                        const slides = slidesData.map(slide => {
                            const slideData = {
                                start: currentTime,
                                end: currentTime + slide.time,
                                content: slide.content
                            };
                            currentTime += slide.time;
                            return slideData;
                        });

                        const totalDuration = currentTime;
                        const fps = 2;
                        const frameDuration = 1000 / fps;
                        let virtualTime = 0;
                        let frameCount = 0;

                        // Initialize capturer
                        this.capturer = new CCapture({
                            format: 'webm',
                            framerate: fps,
                            quality: 85,
                            verbose: false
                        });

                        this.capturer.start();

                        const renderFrame = () => {
                            const currentSlide = this.getCurrentSlide(slides, virtualTime);
                            
                            if (currentSlide) {
                                this.renderSlide(currentSlide.content);
                            } else {
                                this.ctx.fillStyle = "#000";
                                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                            }

                            this.capturer.capture(this.canvas);
                            virtualTime += frameDuration;
                            frameCount++;

                            const progress = (virtualTime / totalDuration) * 100;
                            progressCallback(Math.min(progress, 100));

                            if (virtualTime < totalDuration) {
                                setTimeout(renderFrame, 0);
                            } else {
                                this.capturer.stop();
                                this.capturer.save((blob) => {
                                    resolve(blob);
                                });
                            }
                        };

                        renderFrame();

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            getCurrentSlide(slides, time) {
                for (let slide of slides) {
                    if (time >= slide.start && time < slide.end) {
                        return slide;
                    }
                }
                return null;
            }

            renderSlide(content) {
                const renderer = new CanvasMarkupRenderer(this.ctx, this.canvas.width, this.canvas.height, {
                    fontSize: 28,
                    lineHeight: 42
                });
                renderer.render(content);
            }

            createFinalVideoPlayer(videoBlob, audioElement, prompt, messageContainer) {
                const videoUrl = URL.createObjectURL(videoBlob);
                
                messageContainer.innerHTML = `
                    ‚úÖ <strong>Video created successfully!</strong><br>
                    <em>"${prompt}"</em>
                    
                    <div class="video-container">
                        <video id="generatedVideo" controls style="width: 100%;">
                            <source src="${videoUrl}" type="video/webm">
                        </video>
                    </div>
                    
                   <!-- <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="this.parentElement.parentElement.querySelector('video').play(); this.parentElement.parentElement.querySelector('audio').play();" 
                                style="background: #28a745; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">
                            ‚ñ∂Ô∏è Play with Audio
                        </button>
                        <a href="${videoUrl}" download="explainer-video.webm" 
                           style="background: #007bff; color: white; padding: 10px 15px; border-radius: 5px; text-decoration: none; display: inline-block;">
                            üì• Download Video
                        </a>
                    </div> -->
                    
                    <audio style="display: none;" id="generatedAudio">
                        <source src="${audioElement.src}" type="audio/wav">
                    </audio>
                `;

                // Setup synchronized playback
                const video = messageContainer.querySelector('#generatedVideo');
                const audio = messageContainer.querySelector('#generatedAudio');
                
                if (video && audio) {
                    video.addEventListener('play', () => audio.play());
                    video.addEventListener('pause', () => audio.pause());
                    video.addEventListener('seeked', () => {
                        audio.currentTime = video.currentTime;
                    });
                }
            }
        }

        // Enhanced Markup Renderer (same as your original code)
        class CanvasMarkupRenderer {
            constructor(ctx, width, height, options = {}) {
                this.ctx = ctx;
                this.width = width;
                this.height = height;
                this.x = options.x || 50;
                this.y = options.y || 50;
                this.cursorX = this.x;
                this.cursorY = this.y;
                
                this.config = {
                    defaultFontSize: options.fontSize || 32,
                    lineHeight: options.lineHeight || 48,
                    maxWidth: width - (this.x * 2),
                    listIndent: 40,
                    colors: {
                        text: '#000000',
                        background: '#ffffff'
                    }
                };
                
                this.styleStack = [];
                this.listStack = [];
                this.currentStyle = this.createDefaultStyle();
                this.currentListContext = null;
            }
            
            createDefaultStyle() {
                return {
                    bold: false,
                    italic: false,
                    fontSize: this.config.defaultFontSize,
                    fontFamily: "Arial",
                    color: this.config.colors.text,
                    superscript: false,
                    subscript: false
                };
            }
            
            render(markup) {
                this.ctx.fillStyle = this.config.colors.background;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.cursorX = this.x;
                this.cursorY = this.y + this.config.defaultFontSize;
                
                try {
                    const tokens = this.tokenize(markup);
                    this.processTokens(tokens);
                } catch (error) {
                    console.error("Markup rendering error:", error);
                    this.renderErrorText("Error rendering markup");
                }
            }
            
            tokenize(markup) {
                const regex = /\[([a-zA-Z0-9]+)(?:\s+([^[\]]*))?\]|\[\/([a-zA-Z0-9]+)\]|([^[\]]+)/g;
                const tokens = [];
                let match;
                
                while ((match = regex.exec(markup)) !== null) {
                    if (match[1]) {
                        const attributes = this.parseAttributes(match[2] || "");
                        tokens.push({
                            type: 'open',
                            tag: match[1].toLowerCase(),
                            attributes
                        });
                    } else if (match[3]) {
                        tokens.push({
                            type: 'close',
                            tag: match[3].toLowerCase()
                        });
                    } else if (match[4]) {
                        const text = match[4].trim();
                        if (text) {
                            tokens.push({
                                type: 'text',
                                content: text
                            });
                        }
                    }
                }
                
                return tokens;
            }
            
            parseAttributes(attrString) {
                const attributes = {};
                if (!attrString) return attributes;
                
                const attrRegex = /(\w+)=(?:"([^"]*)"|([^\s]+))/g;
                let match;
                
                while ((match = attrRegex.exec(attrString)) !== null) {
                    attributes[match[1]] = match[2] || match[3];
                }
                
                return attributes;
            }
            
            processTokens(tokens) {
                for (const token of tokens) {
                    switch (token.type) {
                        case 'open':
                            this.handleOpenTag(token.tag, token.attributes);
                            break;
                        case 'close':
                            this.handleCloseTag(token.tag);
                            break;
                        case 'text':
                            this.renderText(token.content);
                            break;
                    }
                }
            }
            
            handleOpenTag(tag, attributes) {
                this.styleStack.push({
                    style: { ...this.currentStyle },
                    listContext: this.currentListContext,
                    cursorX: this.cursorX,
                    cursorY: this.cursorY
                });
                
                switch (tag) {
                    case 'b':
                    case 'strong':
                        this.currentStyle.bold = true;
                        break;
                        
                    case 'i':
                    case 'em':
                        this.currentStyle.italic = true;
                        break;
                        
                    case 'h1':
                    case 'h2':
                    case 'h3':
                    case 'h4':
                    case 'h5':
                    case 'h6':
                        const level = parseInt(tag.charAt(1));
                        this.currentStyle.fontSize = this.config.defaultFontSize + (7 - level) * 8;
                        this.currentStyle.bold = true;
                        this.addLineBreak();
                        break;
                        
                    case 'color':
                        if (attributes.value) {
                            this.currentStyle.color = this.parseColor(attributes.value);
                        }
                        break;
                        
                    case 'size':
                        if (attributes.value) {
                            this.currentStyle.fontSize = parseInt(attributes.value) || this.config.defaultFontSize;
                        }
                        break;
                        
                    case 'sup':
                        this.currentStyle.superscript = true;
                        this.currentStyle.fontSize *= 0.7;
                        break;
                        
                    case 'sub':
                        this.currentStyle.subscript = true;
                        this.currentStyle.fontSize *= 0.7;
                        break;
                        
                    case 'br':
                        this.addLineBreak();
                        break;
                        
                    case 'list':
                        this.startList();
                        break;
                        
                    case 'li':
                        this.startListItem();
                        break;
                }
            }
            
            handleCloseTag(tag) {
                const prevState = this.styleStack.pop();
                
                if (prevState) {
                    if (tag === 'li') {
                        this.endListItem();
                    } else if (tag === 'list') {
                        this.endList();
                    } else if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) {
                        this.addLineBreak();
                    }
                    
                    this.currentStyle = prevState.style;
                    this.currentListContext = prevState.listContext;
                    
                    if (tag === 'sub' || tag === 'sup') {
                        this.cursorY = prevState.cursorY;
                    }
                }
            }
            
            startList() {
                this.listStack.push(this.currentListContext);
                this.currentListContext = {
                    type: 'ul',
                    index: 1,
                    level: this.listStack.length
                };
                this.addLineBreak();
            }
            
            endList() {
                this.currentListContext = this.listStack.pop();
                this.addLineBreak();
            }
            
            startListItem() {
                this.addLineBreak();
                this.cursorX = this.x + (this.config.listIndent * (this.currentListContext?.level || 1));
                this.renderListPrefix();
            }
            
            endListItem() {
                // Handled by line break
            }
            
            renderListPrefix() {
                if (!this.currentListContext) return;
                
                this.applyTextStyle();
                const prefix = '‚Ä¢ ';
                this.ctx.fillText(prefix, this.cursorX, this.cursorY);
                this.cursorX += this.ctx.measureText(prefix).width;
            }
            
            renderText(content) {
                const words = content.split(/\s+/).filter(word => word.length > 0);
                
                for (let i = 0; i < words.length; i++) {
                    this.renderWord(words[i]);
                    if (i < words.length - 1) {
                        this.cursorX += this.ctx.measureText(' ').width;
                    }
                }
            }
            
            renderWord(word) {
                this.applyTextStyle();
                const wordWidth = this.ctx.measureText(word).width;
                
                if (this.cursorX + wordWidth > this.x + this.config.maxWidth) {
                    this.addLineBreak();
                }
                
                let renderY = this.cursorY;
                if (this.currentStyle.superscript) {
                    renderY -= this.currentStyle.fontSize * 0.3;
                } else if (this.currentStyle.subscript) {
                    renderY += this.currentStyle.fontSize * 0.3;
                }
                
                this.ctx.fillStyle = this.currentStyle.color;
                this.ctx.fillText(word, this.cursorX, renderY);
                
                this.cursorX += wordWidth;
            }
            
            applyTextStyle() {
                let fontWeight = this.currentStyle.bold ? 'bold' : 'normal';
                let fontStyle = this.currentStyle.italic ? 'italic' : 'normal';
                
                this.ctx.font = `${fontStyle} ${fontWeight} ${this.currentStyle.fontSize}px ${this.currentStyle.fontFamily}`;
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'alphabetic';
            }
            
            addLineBreak() {
                this.cursorY += this.config.lineHeight;
                this.cursorX = this.x + (this.currentListContext ? 
                    this.config.listIndent * this.currentListContext.level : 0);
            }
            
            parseColor(colorValue) {
                const namedColors = {
                    'red': '#FF0000',
                    'green': '#00FF00',
                    'blue': '#0000FF',
                    'black': '#000000',
                    'white': '#FFFFFF',
                    'gray': '#808080',
                    'yellow': '#FFFF00',
                    'cyan': '#00FFFF',
                    'magenta': '#FF00FF'
                };
                
                if (colorValue.startsWith('#')) {
                    return colorValue;
                } else if (namedColors[colorValue.toLowerCase()]) {
                    return namedColors[colorValue.toLowerCase()];
                }
                
                return this.config.colors.text;
            }
            
            renderErrorText(errorMessage) {
                this.ctx.fillStyle = '#FF0000';
                this.ctx.font = '24px Arial';
                this.ctx.fillText(errorMessage, this.x, this.y + 50);
            }
        }

        // Initialize the chatbot when the page loads
        window.addEventListener('load', () => {
            new ChatBot();
        });
    </script>
</body>
</html>
